pokemon
 
 
口袋DP存档加密至少有三重吧

PokemonMemHack
可以试试跟踪这个修改器

口袋DP的加解密算法，就是跟踪Pokesav修改器的

口袋存档是通过校验和来判断两部分存档的正确与否才会进入游戏

结果出来了
我先说说我的个人猜测吧

我按我的研究说一下口袋存档

以512K为例
每256K为一个部分

一个部分就是一个存档区

如果存档没被破坏，那游戏中会读取游戏进行时间长的那个部分

因为那天我刚开遇到一个“特殊”的存档

才让我知道，口袋的校验码，有三部分
一个是携带PM部分的，一个是Box内部分的
还有个部分，就是每个PM的，这个不理会
关键在携带和Box这两处的校验码

如果这两处的校验没通过，那这个部分的存档就是无效的

那个“特殊”的存档，第一个部分是正确的，第二个部分是校验失败
转换时，读取的正好是第一个部分的，转换后正好正确

接着我把第一个部分和第二部分交换位置，转换工具还是读取第一部分
所以转换出来的存档是校验失败的部分

口袋存档太特殊了
 
如果要加上支持口袋存档，简单的方法，就是判断游戏时长，取游戏时间最长的部分

那就对了，512k转成256k必须舍弃后256k的数据，所以只有第一个存档被转到新存档里

我只研究口袋存档
而这里丢弃后256K对于口袋是不太OK的

口袋特殊，如果转换前的512K存档是正确的
那只要判断两部分的游戏进行的时间，哪个长，就取哪个

512K的口袋存档，256K为一部分

所以256K存档的烧录卡正好

你说的算法实现起来太复杂了，转换软件不可能知道这个存档是不是口袋妖怪的存档，我觉得转换后同时产生两个存档还是可行的。

001.nds.sav 002.nds.sav
但是还是要先告诉软件这个是口袋妖怪的存档。

也可以这样：先产生两转换后存档，然后再比较两个存档，找出时间靠后的。这个可行。


 实验小白鼠 15:47:25
            textgHour.Text = Convert.ToString(getUI16(romStr, romStrBin, 0x86));//游戏时长：时
            textgMin.Text = Convert.ToString(getByte(romStr, romStrBin, 0x88));//游戏时长：分
            textgSec.Text = Convert.ToString(getByte(romStr, romStrBin, 0x89));//游戏时长：秒
小蚂蚁ANTer 15:47:32



口袋怪兽DP存档机制研究
作者: 实验小白鼠  日期: 2007-11-14 17:38
字体大小: 小 中 大  　　今天本打算动手写修改几个参数的口袋DP存档修改器，但发现之前写的程序和Pokesav读取出来的数据不同。
 　　难道是我写错了？调试了一下，发现我写的并没错，Pokesav更是不可能有错。

 　　到底是哪里出现问题了呢？
 　　通过对比发现，Pokesav读取的存档部分与我的不同。
 　　之前写的存档机制中说到，512+KB的存档是分成两部分的，然后存档就是读取替换。难道是这里不对？

 　　竟然有了猜测，就要进行测试。

１、删除$40000后的数据，保存为test1-1.sav。
 　　开机，有存档

２、直接重启，拿存档，取名test1-2.sav。
 　　 数据与test1-1.sav一样。

３、开机，存档，重启，取档，取名test1-3.sav。
 　　 $0-$3ffff数据与test1-2.sav的一样
 　　 $40000后，为新保存的数据。

４、开机，存档，重启，取档，取名test1-4.sav。
 　　 $0-$3ffff为新保存的数据。
 　　 $40000后，与test1-3.sav一样

５、开机，存档，重启，取档，取名test1-5.sav。
 　　 $0-$3ffff数据与test1-4.sav的一样
 　　 $40000后，为新保存的数据。

６、开机，存档，重启，取档，取名test1-6.sav。
 　　 $0-$3ffff为新保存的数据。
  　　$40000后，与test1-5.sav一样

７、开机，存档，重启，取档，取名test1-7.sav。
 　　 $0-$3ffff数据与test1-6.sav的一样
 　　 $40000后，为新保存的数据。
　　按上面的步骤做了存档测试，才知道之前说的“存档机制”是错误的。
正确的是：切换存档。
 　　其实不难理解，不过还是记录下来，稍后置顶的《口袋怪兽钻石存档研究 》也会更新下面说到的存档机制。

 　　还是以512KB的口袋DP存档为例，每40000字节（256KB）为一部分，共两部分（512+KB的存档中多余的8KB全是FF空白数据）。
 　　存档前有记录存档时间的区段，这样的话，两部分存档就由这个存档时间区段区别存档的先后。
 　　每次开始游戏，读取的是都是最后一次的存档。保存的时候，都是覆盖保存最前一次的存档。

 　　举个例来说：按顺序划分为A/B部分，A部分是2007.11.14 10:10存档；B部分是2007.11.14 12:12存档。
 　　开始游戏，读取的是B部分存档，因为它是最后一次保存。
 　　在游戏中保存记录，时间是2007.11.14 20:00，这个记录将覆盖A部分，因为它是最前一次保存的。

 　　以上，没有包括校验存档说明，不过也不难理解。
 　　按我个人的看法，校验存档应该是在判断存档时间之后，也就是说：
 　　判断最后一次存档为B部分，开始校验。
 　　B部分校验正确就继续游戏；如果B部分校验失败，读A部分。
 　　A部分再继续校验。
 　　正确就继续游戏；校验失败，那这个存档完全Broke了。


--------------------------------------------------------------------------------

 　　以上仅是口袋DP存档机制，按之前“他的save都会做两份copy,就算其中一份写坏了，还有另外一份可以拿出来代替”中说的，那读存档应该就是按时间读存的，也就是上面测试得到的结果。

 　　这样，又要写判断存档时间先后的语句了……
 　　一波不平，一波又起……我快死了我。


口袋怪兽DP存档研究:存档时间与游戏时间
作者: 实验小白鼠  日期: 2007-11-15 16:47
字体大小: 小 中 大  　　昨天研究过程中，有几个数值的作用暂时不清楚其作用。今天继续研究了一下，才知道其作用。

 　　首先是年月日后的数值，开始不明白是什么，存档几次也不见改变。但昨天的存档与今天的存档对比，却是变化了。
 　　暂时不明白是什么，就先放着，继续时分秒后的数值。
 　　一开始以为时分秒后的数值是存档的次数，进入游戏中存次档，发现没变化，猜测错误。
 　　到底是什么呢？将其数值换算成10进制，这个数值不大，会不会是与游戏天数相关呢？用程序计算，得到的结果就是当前存档的日期。原来这个时分秒后的数值是当前存档日期距2000-1-1的天数。

 　　搞定一个，就差年月日后的数值了。
 　　昨天14号是03，今天15号是04。把DS主机时间改成16号，此数据变也05；改成17号就变成06。有规律的加1，到底是什么呢？
 　　一下改成11月1日，变成04……郁闷……
 　　继续往后加，改成18号，变成了00。
 　　这下有点感觉了――星期，会不会是星期呢？看了看日历，结果对应上了。
 　　果然是星期。

 　　这样研究出来，就是：年-月-日-星期 时:分:秒 天数。

--------------------------------------------------------------------------------

 　　昨天说到的口袋DP存档分两部分，读取是读最后一次保存的，要计算年月日时分秒，岂不是要判断几个值的大小才能知道哪个部分是最后一次保存的？
 　　突然想到游戏时间。
 　　游戏中不保存记录，那存档时间不会变，游戏时间也不会变。如果保存了，存档时间变了，游戏时间也变了，只不过存档时间是分成几个参数保存的，而游戏时间就一个参数。
 　　也就是说，判断两个部分游戏时间的大小，就可以知道哪个是最后保存的了：大的就是最后保存；小的就是先前保存。
 　　这样就免去了要判断存档时间年月日时分秒了。


--------------------------------------------------------------------------------
 　　突然想到，要是根据存档时间判断先后的话，如果主机时间有变化，那存档再开机，存档不就是……
 　　举个例来说吧。
 　　假设当前存档两部分的存档时间分别为：2007-11-14 10:10和2007-11-15 20:10。
 　　把游戏主机时间改成：2007-1-1 12:00
 　　按之前“判断存档时间读取最后一次存档”的想法读档，读的是2007-11-15 20:10。
 　　在游戏中存档，覆盖的是2007-11-14 10:10，存档时间变成了2007-1-1 12:01（假设玩了一分钟再存档）。
 　　再次开机进入游戏，读取的存档，应该还是读取2007-11-15 20:10，而不是我们后来玩的2007-1-1 12:01。

 　　测试结果，读取的是2007-1-1 12:01。
 　　这也就是说，读档不是按存档时间先后判断的，而是判断游戏时间。
 　　后来玩的“2007-1-1 12:01”虽然调整了时间，但游戏进行的时间在原游戏时间的基础上加了一分钟。而“2007-11-15 20:10”的游戏时间是比前者少一分钟的。

 　　这样就可以避免调整主机时间改变游戏的一些设置了。

--------------------------------------------------------------------------------

 　　最后结果，读取存档是按游戏时间进行的，读取最大的那个部分。





第一存档
0x34-0x37：开始游戏时间（距2000-1-1秒数）	OK
0x3c-0x3f：步入殿堂时间（距2000-1-1秒数）	OK
0x64-0x6f：主角姓名（5全角，7半角）		+4
0x74-0x75：主角ID				+4
0x76-0x77：乐透ID				+4
0x78-0x79：金钱					+4
0x7c：性别（00男，01女）			+4
0x84-0x85：游戏币数				+4?
0x86-0x89：游戏时长				+4
0x86-0x87：游戏时长时				+4
0x88：游戏时长分				+4
0x89：游戏时长秒				+4
0x25a8-0x25ab：劲敌姓名（5全角，7半角）		？
0xc0f0-0xc0f3：存档次数				0xcf1c?
0x5f08-0x5f09：积分				?

0xc0fe-0xc0ff：校验				OK


0x14-0x2f：存档时间				OK
0x14：存档时间年
0x18：存档时间月
0x1c：存档时间日
0x20：存档时间星期
0x24：存档时间时
0x28：存档时间分
0x2c：存档时间秒






看来发布用的还是用Release比较好


 实验小白鼠 11:19:43
************** JIT 调试 ************** 
要启用实时(JIT)调试， 
该应用程序或计算机的 .config 文件(machine.config)的 system.windows.forms 节中必须设置 
jitDebugging 值。 
编译应用程序时还必须启用 
调试。 
 
例如:  
 
<configuration> 
    <system.windows.forms jitDebugging="true" /> 
</configuration> 
 
启用 JIT 调试后，任何无法处理的异常 
都将被发送到在此计算机上注册的 JIT 调试器， 
而不是由此对话框处理。

↑就是看到这个，才感觉可能是Debug的关系
 实验小白鼠 11:20:01
不完全是系统的

 实验小白鼠 11:20:27
前面日文、标点、符号的部分，是原字库的
 实验小白鼠 11:20:39
后面是字库扩容后，添加的GB2312字库

 实验小白鼠 11:21:28
这个在汉化上也常用到，所以比较熟悉～



主窗体：Form1；子窗体：Form2。
 　　在主窗体Form1代码中添加：
Form2 frm2 = new Form2(参数1, 参数2, 参数3, ……);
frm2.Show();
就将参数传到子窗体Form2中了。

 　　在子窗体Form2代码中：
public Form2(接收参数1, 接收参数2, 接收参数3, ……)
        {
            InitializeComponent();
            //在此加入接收参数的使用代码
        }

    交谈中请勿轻信汇款、中奖消息，勿轻易拨打陌生电话。

   该好友不在线，您可以用QQ给他（她）发送手机短信或者发送邮件

 实验小白鼠 11:58:15
全角和半角是游戏中显示的
半角的宽度小，所以能显示7个
全角的宽度大，所以只能显示5个
 实验小白鼠 12:03:44
从姓名开始地址开始，10字节是存储姓名的，其中最后两字节是FFFF表示结束
每两个字节表示一个字，然后根据这两字节，在昨天给的字库索引中找到对应的字。
从0000开始，对应字库索引里的？
因为游戏字库中的0000是空的，所以用这个来显示

小蚂蚁ANTer 12:06:55
明白了，万分感谢
小蚂蚁ANTer 12:12:40
还差问一句，半角字符在存档中也是双字节存储？
 实验小白鼠 12:14:36
嗯
 实验小白鼠 12:14:52
不用往“半角全角”去想
 实验小白鼠 12:15:09
把他们都单作一个独立的字
 实验小白鼠 12:15:39
然后第一个对应的是0000,第二个字对应0001这样
小蚂蚁ANTer 12:16:18
……
知道了，谢谢，我去试试吧

 实验小白鼠 12:16:43
仅仅是涉及读取而不写入
这样就够了
然后再加上：读到FFFF就表示名称结束
小蚂蚁ANTer 12:31:33
问题解决，万分感谢：
姓名空间共有0x10字节，两字节为一个字，最多可以存7个字+1个结尾符，结尾符为“FF FF”。
 实验小白鼠 12:32:10
嗯，是这样的
不过最多7个字仅针对半角字符
 实验小白鼠 12:32:42
英文版取名是，最多七个
日文版取名，最多五个
小蚂蚁ANTer 12:32:43
明白，全角超过5个的话，显示不下
 实验小白鼠 12:33:23
我的理解就是这样
不过没测试超过五个会怎么样
小蚂蚁ANTer 12:33:39
我开始以为半角用一个字节存储，全角用2个字节存储…………
小蚂蚁ANTer 12:34:15
OK，现在存档的信息我已经弄清楚了，呵呵
小蚂蚁ANTer 12:34:43
虽然对我编写的软件没什么用，但我还是想弄明白，再次感谢
小蚂蚁ANTer 12:35:08
祝你的软件能早日超过那个小日本的东西



